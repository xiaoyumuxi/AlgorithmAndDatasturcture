给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例 1：**

![](https://assets.leetcode.com/uploads/2021/02/05/merge.jpg)

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

**示例 2：**

```
输入：root1 = [1], root2 = [1,2]
输出：[2,2]
```

**提示：**

- 两棵树中的节点数目在范围 `[0, 2000]` 内
- `104 <= Node.val <= 104`</br>

这里很关键的一个错误点就在于，没办法对齐
```
Tree C            Tree D
      1                 1
     /                   \
    2                     3
   /
  3
```
Tree C 前序 (带null): [1, 2, 3, null, null, null] (一直往左钻)</br>
Tree D 前序 (带null): [1, null, 3, null, null]</br>

**如果你把它们相加，你就是把 第三层的节点 和 第二层的节点 加在了一起。这在物理空间上是不对等的！**
除非你将其强制进行对齐(使用层序遍历去当成完全二叉树处理)
